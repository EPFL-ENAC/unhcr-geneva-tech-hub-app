<template>
  <v-container fluid>
    <v-row>
      <v-col class="d-flex">
        <h2 class="text-h4 project__h3 font-weight-medium">
          {{ infoTooltipText[$route.name].title }}
        </h2>
        <info-tooltip>
          {{ infoTooltipText[$route.name].text }}
        </info-tooltip>
      </v-col>
    </v-row>
    <v-row>
      <v-col>
        <v-divider></v-divider>
      </v-col>
    </v-row>
    <v-row>
      <v-col
        v-for="(geometry, $index) in geometries"
        v-show="
          shelter_geometry_type === geometry._id || shelter_geometry_type === ''
        "
        :key="$index"
        class="geometry-column"
        :lg="shelter_geometry_type ? 12 : 3"
        :md="shelter_geometry_type ? 12 : 4"
        sm="12"
        xs="12"
      >
        <v-hover v-slot="{ hover }">
          <v-card :elevation="hover ? 12 : 2" :class="{ 'on-hover': hover }">
            <v-card-title
              v-bind="attrs"
              class="d-flex justify-center"
              v-on="on"
              @click="() => toggleImage(geometry._id)"
            >
              <v-btn
                v-if="shelter_geometry_type"
                float
                absolute
                left
                top
                @click.stop="unsetImage"
              >
                Other geometries
              </v-btn>
              <v-img
                max-width="300px"
                max-height="160px"
                class="d-flex justify-center white-background"
                :src="geometry.image_url"
                :aria-label="geometry._id"
              ></v-img>
              <v-btn icon @click.stop="selectedItem = geometry">
                <v-icon>{{ mdiMagnify }}</v-icon>
              </v-btn>
              <!-- <span>{{ geometry._id }}</span> -->
            </v-card-title>
            <v-card-text
              v-if="!geometry.hiddenInputs && shelter_geometry_type"
              class="flex-gap-sm d-flex flex-column justify-space-between"
            >
              <v-expand-transition>
                <v-row v-show="shelter_geometry_type">
                  <v-col :lg="4" :md="6" sm="12" xs="12">
                    <v-card>
                      <v-card-title>Shelter dimensions</v-card-title>
                      <v-form class="pa-md-4">
                        <v-text-field
                          v-for="(
                            dimension, $shelterDimensionsKey
                          ) in geometry.shelter_dimensions"
                          :key="`shelterDimension${$shelterDimensionsKey}`"
                          v-model.number="
                            localShelter.geometry.shelter_dimensions[dimension]
                          "
                          :value="
                            localShelter.geometry.shelter_dimensions[dimension]
                          "
                          :name="dimension"
                          :label="dimension"
                          suffix="m"
                          type="number"
                          @change="updateFormInput"
                        />
                      </v-form>
                    </v-card>
                  </v-col>
                  <v-col
                    v-for="(door, $doorKey) in localShelter.geometry
                      .doors_dimensions"
                    :key="`doorsDimension${$doorKey}`"
                    :lg="4"
                    :md="6"
                    sm="12"
                    xs="12"
                  >
                    <v-card>
                      <!-- v-for on all windows -->
                      <v-card-title>
                        Door dimensions
                        <v-btn icon @click="removeDoor($doorKey)">
                          <v-icon>{{ mdiDelete }}</v-icon>
                        </v-btn>
                      </v-card-title>
                      <v-form class="pa-md-4">
                        <v-text-field
                          v-for="(
                            dimension, $doorDimensionsKey
                          ) in geometry.door_dimensions"
                          :key="`doorDimension${$doorDimensionsKey}`"
                          v-model.number="
                            localShelter.geometry.doors_dimensions[$doorKey][
                              dimension
                            ]
                          "
                          :name="dimension"
                          :label="dimension"
                          suffix="m"
                          type="number"
                          @change="updateFormInput"
                        />
                      </v-form>
                    </v-card>
                  </v-col>
                  <v-col
                    v-for="(window, $windowKey) in localShelter.geometry
                      .windows_dimensions"
                    :key="`windowsDimensions${$windowKey}`"
                    :lg="4"
                    :md="6"
                    sm="12"
                    xs="12"
                  >
                    <v-card>
                      <!-- v-for on all windows -->
                      <v-card-title class="d-flex justify-space-between">
                        Window dimensions
                        <v-btn icon @click="removeWindow($windowKey)">
                          <v-icon>{{ mdiDelete }}</v-icon>
                        </v-btn>
                      </v-card-title>
                      <v-form class="pa-md-4">
                        <v-text-field
                          v-for="(
                            dimension, $windowDimensions
                          ) in geometry.window_dimensions"
                          :key="`windowDimensions${$windowDimensions}`"
                          v-model.number="
                            localShelter.geometry.windows_dimensions[
                              $windowKey
                            ][dimension]
                          "
                          :name="dimension"
                          :label="dimension"
                          suffix="m"
                          type="number"
                          @change="updateFormInput"
                        />
                      </v-form>
                    </v-card>
                  </v-col>
                  <v-col :lg="4" :md="6" sm="12" xs="12">
                    <v-btn block class="my-4" @click="addDoor">
                      <v-icon left>{{ mdiPlusBox }} </v-icon> Add door</v-btn
                    >
                    <v-btn block @click="addWindow"
                      ><v-icon left>{{ mdiPlusBox }} </v-icon> Add window</v-btn
                    >
                  </v-col>
                </v-row>
              </v-expand-transition>
            </v-card-text>
            <v-card v-if="shelter_geometry_type">
              <v-card-title> Result dimensions </v-card-title>
              <v-card-text>
                <v-row>
                  <v-col
                    v-for="(resultDimension, $key) in dimensions"
                    :key="$key"
                    :lg="4"
                    :md="6"
                    sm="12"
                    xs="12"
                  >
                    <v-text-field
                      v-model.number="
                        localShelter.geometry[resultDimension.key]
                      "
                      :name="resultDimension.label"
                      :label="resultDimension.label"
                      type="number"
                      :disabled="!geometry.hiddenInputs"
                      :suffix="resultDimension.suffix"
                      @change="updateResultDimension"
                    >
                    </v-text-field>
                  </v-col>
                </v-row>
              </v-card-text>
            </v-card>
          </v-card>
        </v-hover>
      </v-col>
    </v-row>

    <v-overlay v-if="selectedItem" @click="selectedItem = null">
      <v-img
        :src="selectedItem ? selectedItem.image_url : ''"
        contain
        class="d-flex justify-center white-background"
        @click="selectedItem = null"
      ></v-img>
    </v-overlay>
  </v-container>
</template>

<script lang="ts">
import InfoTooltip from "@/components/commons/InfoTooltip.vue";
import { infoTooltipText } from "@/components/shelter_sustainability/infoTooltipText";
import {
  DoorDimensions,
  GeometryKeys,
  Shelter,
  ShelterDimensions,
  WindowDimensions,
} from "@/store/ShelterInterface";
import { getNewGeometry } from "@/store/ShelterModuleUtils";
import { mdiDelete, mdiMagnify, mdiPlusBox } from "@mdi/js";
import { cloneDeep } from "lodash";
import { Component, Prop, Vue, Watch } from "vue-property-decorator";
/* two ways to have a store copy locally
1. having a watcher on the store that cloneDeep to data() locally
2. having a subscriber to mutation that's initialized at created
cf: https://forum.vuejs.org/t/best-way-to-use-forms-with-local-state-using-v-model-and-sync-to-vuex-store-on- /24739
for the original discussion
*/
@Component({
  components: {
    InfoTooltip,
  },
})
/** Project */
export default class Step2Geometry extends Vue {
  @Prop({ type: [Object], required: true })
  shelter!: Shelter;

  mdiMagnify = mdiMagnify;
  mdiDelete = mdiDelete;
  mdiPlusBox = mdiPlusBox;

  public get localShelter(): Shelter {
    return cloneDeep(this.shelter);
  }

  public set localShelter(newShelter: Shelter) {
    this.$emit("update:shelter", newShelter);
  }

  public updateFormInput(): void {
    this.localShelter = Object.assign({}, this.localShelter);
  }
  selectedItem = null;
  infoTooltipText = infoTooltipText;
  public toggleImage(_id: string): void {
    if (this.localShelter.geometry.shelter_geometry_type === "") {
      this.localShelter.geometry.shelter_geometry_type = _id;
    } else {
      this.localShelter.geometry.shelter_geometry_type = "";
    }
    this.updateFormInput();
  }
  public unsetImage(): void {
    this.localShelter.geometry.shelter_geometry_type = "";
    this.updateFormInput();
  }

  public updateResultDimension(value: string, field: GeometryKeys): void {
    this.localShelter.geometry[field] = parseFloat(value);
    this.updateFormInput();
  }
  get shelter_geometry_type(): string {
    return this.localShelter?.geometry?.shelter_geometry_type;
  }

  public addDoor(): void {
    this.localShelter.geometry.doors_dimensions.push({ Wd: 0, Hd: 0 });
    this.updateFormInput();
  }
  public removeDoor(index: number): void {
    this.localShelter.geometry.doors_dimensions.splice(index, 1);
    this.updateFormInput();
  }

  public addWindow(): void {
    this.localShelter.geometry.windows_dimensions.push({ Ww: 0, Hw: 0, Hs: 0 });
    this.updateFormInput();
  }
  public removeWindow(index: number): void {
    this.localShelter.geometry.windows_dimensions.splice(index, 1);
    this.updateFormInput();
  }

  public get hasComputedFloorAndVolume(): boolean {
    const geometryType =
      this.localShelter?.geometry?.shelter_geometry_type ?? "";
    return (
      geometryType.indexOf(this.geometryOtherName) === -1 && geometryType !== ""
    );
  }

  @Watch("localShelter.geometry.shelter_dimensions", {
    deep: true,
    immediate: true,
  })
  onShelterDimensionsChange(newShelterDimensions: ShelterDimensions): void {
    if (newShelterDimensions && this.hasComputedFloorAndVolume) {
      // we need at least L && W for floor Area and Volume
      // works for other since L & W will always be zero for 'Others' type of geometry
      this.localShelter.geometry.floorArea =
        this.floorArea(newShelterDimensions);
      this.localShelter.geometry.volume =
        this.computeVolume(newShelterDimensions);
    }
  }

  @Watch("localShelter.geometry.windows_dimensions", {
    deep: true,
    immediate: true,
  })
  public onWindowsDimensionsChange(
    newWindowDimensions: WindowDimensions[]
  ): void {
    if (newWindowDimensions && this.hasComputedFloorAndVolume) {
      const res =
        this.windowDimensions(newWindowDimensions) +
        this.doorDimensions(this.localShelter.geometry.doors_dimensions);
      this.localShelter.geometry.windowArea = parseFloat(res.toFixed(2));
    }
  }

  @Watch("localShelter.geometry.doors_dimensions", {
    deep: true,
    immediate: true,
  })
  public onDoorsDimensionsChange(newDoorDimensions: DoorDimensions[]): void {
    if (newDoorDimensions && this.hasComputedFloorAndVolume) {
      const res =
        this.windowDimensions(this.localShelter.geometry.windows_dimensions) +
        this.doorDimensions(newDoorDimensions);
      this.localShelter.geometry.windowArea = parseFloat(res.toFixed(2));
    }
  }

  @Watch("localShelter.geometry.shelter_geometry_type", { immediate: false })
  public onGeometryTypeChange(shelter_geometry_type: string): void {
    // reset all dimensions when no shelter geometry selected
    if (shelter_geometry_type === "") {
      this.localShelter.geometry = {
        ...getNewGeometry(),
        shelter_geometry_type,
      };
    }
  }

  private doorDimensions(doorDimensions: DoorDimensions[]): number {
    if (doorDimensions.length === 0) {
      return 0;
    }
    return doorDimensions
      .map(({ Wd, Hd }) => {
        if (!Wd || !Hd) {
          return 0; // missing Wd or Hd area is 0
        }
        return Wd * Hd;
      })
      .reduce((doorsArea, doorArea) => doorsArea + doorArea);
  }
  // externalize somehwere
  private windowDimensions(windowDimensions: WindowDimensions[]): number {
    if (windowDimensions.length === 0) {
      return 0;
    }
    return windowDimensions
      .map(({ Ww, Hw }) => {
        if (!Ww || !Hw) {
          return 0; // missing Ww or Hw area is 0
        }
        return Ww * Hw;
      })
      .reduce((windowsArea, windowArea) => windowsArea + windowArea);
  }

  private floorArea(shelterDimension: ShelterDimensions): number {
    const { L, W } = shelterDimension || {};
    let res = 0;
    if (!L || !W) {
      return res; // Length or Width not defined
    }
    if (this.shelter_geometry_type === "dome") {
      const surfaceAreaEllipse = Math.PI * (L / 2) * (W / 2);
      // better to use toPrecision(3)
      res = Math.floor(surfaceAreaEllipse * 100) / 100;
    } else {
      res = L * W;
    }
    return parseFloat(res.toFixed(2));
  }

  private computeVolume(shelterDimension: ShelterDimensions): number {
    const geometry = this.geometries.find(
      (g) => g._id === this.shelter_geometry_type
    );
    if (geometry?.volumeFunction) {
      const res = geometry.volumeFunction(shelterDimension);
      return parseFloat(res.toFixed(2));
    }
    throw new Error("should not have a volume");
  }

  dimensions = [
    { label: "Floor area", key: "floorArea", suffix: "m²" },
    { label: "Volume", key: "volume", suffix: "m³" },
    { label: "Openings area", key: "windowArea", suffix: "m²" },
  ];

  geometryOtherName = "other";

  geometries = [
    {
      _id: "gableHW", // High wall
      name: "Gable roof",
      image_url: "/houses_new/SSC_P1_Shelter-GableHW_220201.png",
      shelter_dimensions: ["L", "W", "H1", "H2"],
      door_dimensions: ["Wd", "Hd"],
      window_dimensions: ["Ww", "Hw", "Hs"],
      volumeFunction(shelterDimension: ShelterDimensions): number {
        const { L, W, H1, H2 } = shelterDimension || {};
        if (!L || !W || !H1 || !H2) {
          return 0; // one dimension undefined volume is 0 by default
        }
        return L * W * H1 + 0.5 * L * W * (H2 - H1);
      },
    },
    {
      _id: "flatRoof",
      name: "Single pitch roof",
      image_url: "/houses_new/SSC_P3_Shelter-FlatRoof_220201.png",
      shelter_dimensions: ["L", "W", "H"],
      door_dimensions: ["Wd", "Hd"],
      window_dimensions: ["Ww", "Hw", "Hs"],
      volumeFunction(shelterDimension: ShelterDimensions): number {
        const { L, W, H } = shelterDimension || {};
        if (!L || !W || !H) {
          return 0; // one dimension undefined volume is 0 by default
        }
        return L * W * H;
      },
    },
    {
      _id: "dome",
      name: "Dome",
      image_url: "/houses_new/SSC_P4_Shelter-Dome_220201.png",
      shelter_dimensions: ["L", "W", "H"],
      door_dimensions: ["Wd", "Hd"],
      window_dimensions: ["Ww", "Hw", "Hs"],
      volumeFunction(shelterDimension: ShelterDimensions): number {
        const { L, W, H } = shelterDimension || {};
        if (!L || !W || !H) {
          return 0; // one dimension undefined volume is 0 by default
        }
        return 0.1666667 * Math.PI * L * W * H;
      },
    },
    {
      _id: this.geometryOtherName,
      name: "Other",
      hiddenInputs: true,
      image_url: "/houses_new/GTH-SSC_Graphics_Typology_Other_5.png",
    },
  ];
}
</script>

<style lang="scss">
.flex-gap-sm {
  gap: 16px;
}
</style>

<style scoped>
.v-card {
  transition: opacity 0.2s ease-in-out;
  cursor: pointer;
}

.white-background {
  background-color: white;
}
</style>
